package de.hhu.bsinfo.observatory.benchmark;

import de.hhu.bsinfo.jdetector.lib.IbFabric;
import de.hhu.bsinfo.jdetector.lib.IbPerfCounter;
import de.hhu.bsinfo.jdetector.lib.exception.IbFileException;
import de.hhu.bsinfo.jdetector.lib.exception.IbMadException;
import de.hhu.bsinfo.jdetector.lib.exception.IbNetDiscException;
import de.hhu.bsinfo.jdetector.lib.exception.IbVerbsException;
import de.hhu.bsinfo.observatory.benchmark.config.DetectorConfig;
import de.hhu.bsinfo.observatory.benchmark.config.DetectorConfig.MeasurementMode;
import de.hhu.bsinfo.observatory.benchmark.result.Status;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * This class is the core of Observatory. Each benchmark has to implement this class.
 * It holds instances of all {@link BenchmarkPhase}s, as well as the information, which is necessary to run each phase.
 * The class {@link Observatory} creates instances of {@link Benchmark} implementations according to the configuration
 * and configures each instance by calling the setter-methods.
 * To start the benchmark, {@link #executePhases()} is called, which will run all benchmark phases consecutively.
 * The flow of each benchmark is described in the following figure:
 *
 *                                     Instantiate implementation of {@link Benchmark}
 *                                                          |
 *                                                          |
 *                                                          ∨
 *                      Configure {@link Benchmark} instance (setParameter(), setRemoteAddress(), ...)
 *                                                          |
 *                                                          |
 *                                                          ∨
 *      Add {@link BenchmarkPhase}s ({@link PreparationPhase}, {@link WarmUpPhase}, {@link OperationPhase}, ...)
 *                                                          |
 *                                                          |
 *                                                          ∨
 *                 Execute the {@link BenchmarkPhase}s consecutively by calling {@link #executePhases()}
 *
 * An implementation of {@link Benchmark} should only implement the default constructor, as this is what the
 * {@link Observatory} main class is looking for, when instantiating a {@link Benchmark}.
 *
 * Each pair of benchmarks sets up a TCP-Socket based connection, which can be used by an implementation (e.g. for
 * exchanging InfiniBand connection information). The socket can be retrieved by calling {@link #getOffChannelSocket()}.
 *
 * @author Fabian Ruhland, Fabian Ruhland@hhu.de
 */
public abstract class Benchmark {

    /**
     * SLF4J Logger instance for logging information.
     */
    private static final Logger LOGGER = LoggerFactory.getLogger(Benchmark.class);

    /**
     * A string, that is sent/received when synchronizing benchmarks with {@link #synchronize()}.
     */
    private static final String SYNC_SIGNAL = "SYNC";

    /**
     * A benchmark is either running in SEND or RECEIVE mode.
     */
    public enum Mode {
        SEND, RECEIVE
    }

    /**
     * When using rdma, a benchmark can either READ or WRITE data.
     */
    public enum RdmaMode {
        READ, WRITE
    }

    /**
     * Path to the result folder, in which each operation will save its measurements.
     */
    private String resultPath;

    /**
     * The name, that is being used in the result files to identify this benchmark.
     */
    private String resultName;

    /**
     * The iteration, that is being run.
     */
    private int iterationNumber;

    /**
     * Whether this instance is running as server or client.
     */
    private boolean isServer;

    /**
     * The amount of retries, after connecting to a sever has failed.
     */
    private int connectionRetries;

    /**
     * The address to bind the {@link #offChannelSocket} to.
     */
    private InetSocketAddress bindAddress;

    /**
     * The address to connect the {@link #offChannelSocket} to.
     */
    private InetSocketAddress remoteAddress;

    /**
     * Holds information on how jDetector shall be configured.
     * jDetector is an external library, which can be used to read the performance counters of InfiniBand HCAs.
     * Observatory uses jDetector to measure the data overhead, that is generated by each implementation.
     */
    private DetectorConfig detectorConfig;

    /**
     * A TCP-Socket used for exchanging data between two benchmark instances (e.g. InfiniBand connection information).
     * This socket is also used by {@link #synchronize()}.
     */
    private Socket offChannelSocket;

    /**
     * Holds all local InfiniBand HCAs, that were found by jDetector.
     */
    private IbFabric fabric;

    /**
     * The InfiniBand HCA, that should be used for overhead measurements.
     * The HCA is chosen by the {@link DetectorConfig}.
     */
    private IbPerfCounter perfCounter;

    /**
     * The user-defined parameters for a {@link Benchmark} implementation.
     * These are read from the {@link de.hhu.bsinfo.observatory.benchmark.config.BenchmarkConfig} and can be retrieved
     * by calling {@link #getParameter(String key, String defaultValue)}.
     */
    private final Map<String, String> parameters = new HashMap<>();

    /**
     * A list, holding all {@link BenchmarkPhase}s in their correct execution order.
     */
    private final List<BenchmarkPhase> phases = new ArrayList<>();

    void addBenchmarkPhase(BenchmarkPhase phase) {
        phases.add(phase);
    }

    void setParameter(final String key, final String value) {
        parameters.put(key, value);
    }

    protected String getParameter(String key, String defaultValue) {
        return parameters.getOrDefault(key, defaultValue);
    }

    protected byte getParameter(String key, byte defaultValue) {
        return Byte.parseByte(parameters.getOrDefault(key, String.valueOf(defaultValue)));
    }

    protected short getParameter(String key, short defaultValue) {
        return Short.parseShort(parameters.getOrDefault(key, String.valueOf(defaultValue)));
    }

    protected int getParameter(String key, int defaultValue) {
        return Integer.parseInt(parameters.getOrDefault(key, String.valueOf(defaultValue)));
    }

    protected long getParameter(String key, long defaultValue) {
        return Long.parseLong(parameters.getOrDefault(key, String.valueOf(defaultValue)));
    }

    protected Socket getOffChannelSocket() {
        return offChannelSocket;
    }

    public String getResultName() {
        return resultName;
    }

    boolean isServer() {
        return isServer;
    }

    int getConnectionRetries() {
        return connectionRetries;
    }

    InetSocketAddress getBindAddress() {
        return bindAddress;
    }

    InetSocketAddress getRemoteAddress() {
        return remoteAddress;
    }

    String getResultPath() {
        return resultPath;
    }

    int getIterationNumber() {
        return iterationNumber;
    }

    boolean measureOverhead() {
        return detectorConfig.isEnabled();
    }

    IbPerfCounter getPerfCounter() {
        return perfCounter;
    }

    public void setResultName(String name) {
        this.resultName = name;
    }

    void setServer(final boolean server) {
        isServer = server;
    }

    void setConnectionRetries(final int connectionRetries) {
        this.connectionRetries = connectionRetries;
    }

    void setBindAddress(final InetSocketAddress bindAddress) {
        this.bindAddress = bindAddress;
    }

    void setRemoteAddress(final InetSocketAddress remoteAddress) {
        this.remoteAddress = remoteAddress;
    }

    void setResultPath(final String resultPath) {
        this.resultPath = resultPath;
    }

    public void setIterationNumber(int iterationNumber) {
        this.iterationNumber = iterationNumber;
    }

    void setDetectorConfig(final DetectorConfig detectorConfig) {
        this.detectorConfig = detectorConfig;
    }

    Status setup() {
        if(detectorConfig.isEnabled()) {
            LOGGER.info("Initializing jDetector");

            try {
                fabric = new IbFabric(false, detectorConfig.getMode() == MeasurementMode.COMPAT);
            } catch (IbFileException | IbMadException | IbVerbsException | IbNetDiscException e) {
                LOGGER.error("Unable to initialize jDetector!", e);
                return Status.UNKNOWN_ERROR;
            }

            if (fabric.getNumNodes() == 0) {
                LOGGER.error("Fabric scanned by jDetector: 0 devices found!");
                return Status.UNKNOWN_ERROR;
            } else {
                LOGGER.info("Fabric scanned by jDetector: {} {} found", fabric.getNumNodes(), fabric.getNumNodes() == 1 ? "device was" : "devices were");
            }

            LOGGER.info("Measuring overhead on {}", fabric.getNodes()[detectorConfig.getDeviceNumber()].getDescription());

            perfCounter = fabric.getNodes()[detectorConfig.getDeviceNumber()];
        }

        LOGGER.info("Setting up connection for off channel communication");

        if (isServer) {
            LOGGER.info("Listening on address {}", bindAddress.toString());

            try {
                ServerSocket serverSocket = new ServerSocket(bindAddress.getPort(), 0, bindAddress.getAddress());
                offChannelSocket = serverSocket.accept();

                serverSocket.close();
            } catch (IOException e) {
                LOGGER.error("Setting up off channel communication failed", e);

                return Status.NETWORK_ERROR;
            }
        } else {
            LOGGER.info("Connecting to server {}", remoteAddress.toString());

            int attempt = 0;
            while(true) {
                try {
                    offChannelSocket = new Socket(remoteAddress.getAddress(), remoteAddress.getPort(),
                            bindAddress.getAddress(), bindAddress.getPort());

                    break;
                } catch (IOException e) {
                    if(attempt < connectionRetries) {
                        attempt++;

                        try {
                            Thread.sleep(100);
                        } catch (InterruptedException ignored) {}
                    } else {
                        LOGGER.error("Setting up off channel communication failed", e);

                        return Status.NETWORK_ERROR;
                    }
                }
            }
        }

        LOGGER.info("Succesfully connected to {}", offChannelSocket.getRemoteSocketAddress());

        return Status.OK;
    }

    private boolean sendSync() {
        try {
            new DataOutputStream(offChannelSocket.getOutputStream()).write(SYNC_SIGNAL.getBytes());

            return true;
        } catch (IOException e) {
            return false;
        }
    }

    private boolean receiveSync() {
        try {
            byte[] bytes = new byte[SYNC_SIGNAL.getBytes().length];
            new DataInputStream(offChannelSocket.getInputStream()).readFully(bytes);

            String received = new String(bytes);

            if (!received.equals(SYNC_SIGNAL)) {
                LOGGER.error("Received invalid signal (Got '{}', Expected '{}')", received, SYNC_SIGNAL);
                return false;
            }

            return true;
        } catch (IOException e) {
            return false;
        }
    }

    boolean synchronize() {
        LOGGER.info("Synchronizing with remote benchmark");

        if(!sendSync() || !receiveSync()) {
            LOGGER.error("Unable to synchronize with remote benchmark");
            return false;
        }

        LOGGER.info("Synchronized with remote benchmark");

        return true;
    }

    void executePhases() {
        for(BenchmarkPhase phase : phases) {
            String phaseName = phase.getClass().getSimpleName();

            LOGGER.info("Running {}", phaseName);

            Status status = phase.execute();

            if(status == Status.NOT_IMPLEMENTED) {
                LOGGER.warn("{} returned [{}] and is being skipped", phaseName, status);
                continue;
            }

            if(status != Status.OK) {
                LOGGER.error("{} failed with status [{}]", phaseName, status);
                System.exit(1);
            }

            LOGGER.info("{} finished with status [{}]", phaseName, status);
        }

        try {
            offChannelSocket.close();
        } catch (IOException e) {
            LOGGER.error("Closing off channel communication failed", e);
        }

        if(detectorConfig.isEnabled()) {
            fabric.close();
        }
    }

    protected abstract Status initialize();

    protected abstract Status serve(final InetSocketAddress bindAddress);

    protected abstract Status connect(final InetSocketAddress bindAddress, final InetSocketAddress serverAddress);

    protected abstract Status prepare(final int operationSize);

    protected abstract Status cleanup();

    protected abstract Status fillReceiveQueue();

    protected abstract Status sendMultipleMessages(int messageCount);

    protected abstract Status receiveMultipleMessage(int messageCount);

    protected abstract Status performMultipleRdmaOperations(RdmaMode mode, int operationCount);

    protected abstract Status sendSingleMessage();

    protected abstract Status performSingleRdmaOperation(RdmaMode mode);

    protected abstract Status performPingPongIterationServer();

    protected abstract Status performPingPongIterationClient();
}
